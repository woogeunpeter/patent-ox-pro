<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>특허법 OX — 풀이·편집 (빈 문제은행)</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="특허법 OX">
<link rel="apple-touch-icon" href="icons/icon-180.png">
<meta name="theme-color" content="#ffffff">
<style>
  :root { --gap: 12px; --radius: 10px; }
  body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Noto Sans KR', 'Apple SD Gothic Neo', 'Malgun Gothic', 'Helvetica Neue', Arial, sans-serif;
         margin: 0; background: #f6f7f9; color: #111; }
  header { position: sticky; top: 0; background: #fff; border-bottom: 1px solid #e5e7eb; padding: 12px 16px; display: flex; gap: 8px; align-items: center; z-index: 10; }
  header input[type="text"]{ flex: 1; padding: 10px 12px; border: 1px solid #e5e7eb; border-radius: 8px; }
  header button { padding: 10px 12px; border: 1px solid #e5e7eb; background: #fff; border-radius: 8px; cursor: pointer; }
  header button:hover { background: #f1f5f9; }
  .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; }
  .toolbar { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0 16px; }
  .card { position: relative; background: #fff; border: 1px solid #e5e7eb; border-radius: var(--radius); padding: 16px; margin-bottom: var(--gap); box-shadow: 0 1px 0 rgba(16,24,40,0.04); }
  .card.review { outline: 2px dashed #f59e0b; }
  .meta { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; font-size: 13px; color: #475569; }
  .badge { padding: 2px 8px; border-radius: 999px; background: #f1f5f9; border: 1px solid #e5e7eb; }
  .trap { background: #eef2ff; border-color: #e0e7ff; }
  .editpin { position: absolute; right: 12px; top: 12px; font-size: 12px; opacity: .9; }
  .editpin button { padding: 6px 8px; border: 1px solid #e5e7eb; background: #fff; border-radius: 999px; cursor: pointer; }
  .editpin button:hover { background: #f1f5f9; }
  .question { font-size: 16px; line-height: 1.6; margin-bottom: 12px; }
  .actions { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
  .actions button { padding: 8px 10px; border: 1px solid #e5e7eb; background: #fff; border-radius: 8px; cursor: pointer; }
  .actions button.active { background: #e5ffe7; border-color: #bbf7d0; }
  details { background: #fafafa; border: 1px solid #e5e7eb; border-radius: 8px; padding: 8px 10px; }
  summary { cursor: pointer; user-select: none; }
  .editor { margin-top: 12px; border-top: 1px dashed #e5e7eb; padding-top: 12px; display: none; }
  .editor label { display: block; font-size: 12px; color: #475569; margin-top: 8px; }
  .editor input[type="text"], .editor textarea { width: 100%; padding: 8px 10px; border: 1px solid #e5e7eb; border-radius: 8px; font-size: 14px; }
  .editor .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .muted { color: #64748b; font-size: 12px; }
  .small { font-size: 12px; }
  .footer { text-align: center; color: #64748b; font-size: 12px; padding: 24px 12px; }
  .editmode-on { background: #eefbf1; border-color: #bbf7d0; }
  .hl { margin-top: 8px; padding: 8px; background: #fff; border: 1px dashed #e5e7eb; border-radius: 8px; }
  .hl .title { font-weight: 600; font-size: 12px; color: #334155; margin-bottom: 4px; }
  .tok-ins { text-decoration: underline; text-decoration-style: solid; }
  .tok-del { text-decoration: line-through; opacity: .6; }
  .tok-chg { background: #fff3cd; }
  .empty { background: #fff; border: 1px dashed #e5e7eb; padding: 14px; border-radius: 10px; color: #475569; }
</style>
</head>
<body>
<header>
  <strong>풀이·편집 모드 v3 (Blank)</strong>
  <input id="search" type="text" placeholder="검색: 조문/문제/해설/트랩유형" />
  <button id="btnToggleEdit">편집 모드: <span id="editState">OFF</span></button>
  <button id="btnAdd">+ 새 문제</button>
  <button id="btnExportJson">JSON 내보내기</button>
  <button id="btnExportCsv">CSV 내보내기</button>
  <button id="btnImport">JSON 가져오기</button>
  <button id="btnReset">초기화</button>
</header>
<div class="wrap">
  <div class="toolbar small">
    • 카드 포커스 단축키: <b>O</b>=O, <b>X</b>=X, <b>E</b>=편집, <b>S</b>=저장, <b>M</b>=검토표시<br/>
    • <b>편집 모드</b> ON → 카드 탭/클릭 시 해당 문항 편집기 즉시 오픈. 우상단 <b>✎ 편집</b>으로도 바로 진입.<br/>
    • <b>하이라이트</b>는 “해설(원문)”과 “문제문”을 단어 단위로 비교해 변경 지점을 표시합니다.
  </div>
  <div id="list"></div>
  <div id="empty" class="empty" style="display:none">아직 문항이 없습니다. “+ 새 문제”를 눌러 추가하시거나, JSON을 가져오세요.</div>
  <div class="footer">로컬 저장(localStorage). JSON/CSV로 백업하세요.</div>
</div>

<script>
const STORAGE_KEY = "patent_ox_items_v1";  // 이름 고정
const SETTINGS_KEY = "patent_ox_settings_v1";

function uid() { return "P-" + Math.random().toString(36).slice(2, 8); }

// ⬇️ 빈 문제은행(배열)로 시작
const initial = [];

function load() {
  const saved = localStorage.getItem(STORAGE_KEY);
  return saved ? JSON.parse(saved) : initial;
}
function save(items) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
}
function loadSettings(){
  const s = localStorage.getItem(SETTINGS_KEY);
  return s ? JSON.parse(s) : { editMode:false, currentEditId:null };
}
function saveSettings(s){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); }

let items = load();
let settings = loadSettings();

(function parseHash(){
  const m = location.hash.match(/edit=([A-Za-z0-9\-]+)/);
  if (m){ settings.editMode = true; settings.currentEditId = m[1]; saveSettings(settings); }
})();

function h(tag, attrs={}, ...children){
  const el = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) {
    if (k === "class") el.className = v;
    else if (k.startsWith("on")) el.addEventListener(k.slice(2).toLowerCase(), v);
    else if (k === "html") el.innerHTML = v;
    else el.setAttribute(k, v);
  }
  for (const c of children) {
    if (typeof c === "string") el.appendChild(document.createTextNode(c));
    else if (c) el.appendChild(c);
  }
  return el;
}

// --- Diff for highlight (원문 vs 문제문) ---
function diffTokens(a, b){
  const wa = a.split(/(\\s+)/);
  const wb = b.split(/(\\s+)/);
  const n = wa.length, m = wb.length;
  const dp = Array(n+1).fill(0).map(()=>Array(m+1).fill(0));
  for (let i=1;i<=n;i++) for (let j=1;j<=m;j++)
    dp[i][j] = (wa[i-1]===wb[j-1]) ? dp[i-1][j-1]+1 : Math.max(dp[i-1][j], dp[i][j-1]);
  const ops = []; let i=n,j=m;
  while(i>0 && j>0){
    if (wa[i-1]===wb[j-1]){ ops.push({type:"eq", a:wa[i-1]}); i--; j--; }
    else if (dp[i-1][j] >= dp[i][j-1]){ ops.push({type:"del", a:wa[i-1]}); i--; }
    else { ops.push({type:"ins", b:wb[j-1]}); j--; }
  }
  while(i>0){ ops.push({type:"del", a:wa[i-1]}); i--; }
  while(j>0){ ops.push({type:"ins", b:wb[j-1]}); j--; }
  ops.reverse();
  const merged = [];
  for (let k=0;k<ops.length;k++){
    const cur = ops[k]; const prev = merged[merged.length-1];
    if (prev && prev.type==="del" && cur.type==="ins"){ merged[merged.length-1] = { type:"chg", a: prev.a, b: cur.b }; }
    else merged.push(cur);
  }
  return merged;
}
function escapeHtml(s){ return s.replace(/[&<>\"']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\\\"":"&quot;","'":"&#39;" }[c])); }
function renderDiff(aRaw, qRaw){
  const a = (aRaw||"").trim(), q = (qRaw||"").trim();
  if (!a || !q) return "<em class='muted'>원문이나 문제문이 비어 있어 하이라이트를 표시할 수 없습니다.</em>";
  const ops = diffTokens(a, q);
  const left = [], right = [];
  for (const op of ops){
    if (op.type==="eq"){ left.push(escapeHtml(op.a)); right.push(escapeHtml(op.a)); }
    else if (op.type==="del"){ left.push("<span class='tok-del'>"+escapeHtml(op.a)+"</span>"); }
    else if (op.type==="ins"){ right.push("<span class='tok-ins'>"+escapeHtml(op.b)+"</span>"); }
    else if (op.type==="chg"){
      left.push("<span class='tok-del tok-chg'>"+escapeHtml(op.a)+"</span>");
      right.push("<span class='tok-ins tok-chg'>"+escapeHtml(op.b)+"</span>");
    }
  }
  return "<div class='hl'><div class='title'>원문 대비 문제문 차이</div><div><div class='small muted'>왼쪽=원문, 오른쪽=문제문</div></div><div style='display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:6px'><div>"+left.join("")+"</div><div>"+right.join("")+"</div></div></div>";
}

// --- Render ---
function render(){
  document.getElementById("editState").textContent = settings.editMode ? "ON" : "OFF";
  const q = document.getElementById("search").value.trim().toLowerCase();
  const root = document.getElementById("list");
  const empty = document.getElementById("empty");
  root.innerHTML = "";
  let count = 0;
  let firstVisibleCard = null;
  items.forEach((it, idx)=>{
    if (q && !((it.articleLabel||'') + ' ' + (it.questionText||'') + ' ' + (it.explanation||'') + ' ' + (it.trapTypes||'') + ' ' + (it.compareNote||'')).toLowerCase().includes(q)) return;
    count++;
    const card = h("div", {class:"card", tabindex:"0", id: it.id});
    if (!firstVisibleCard) firstVisibleCard = card;
    if (it.markReview) card.classList.add("review");
    if (settings.editMode) card.classList.add("editmode-on");
    if (settings.editMode){
      card.addEventListener("click", (ev)=>{
        if ((ev.target.tagName === "BUTTON" || ev.target.closest(".editor") || ev.target.closest("details"))) return;
        openEditorFor(it.id);
      });
    }
    const meta = h("div",{class:"meta"},
      h("span",{class:"badge"}, it.articleLabel || "—"),
      h("span",{class:"badge trap"}, it.trapTypes || "트랩미지정"),
      h("span",{class:"muted"}, `ID: ${it.id}`),
    );
    const pin = h("div",{class:"editpin"},
      h("button",{onclick:(e)=>{ e.stopPropagation(); quickEdit(it.id); }}, "✎ 편집")
    );
    const question = h("div",{class:"question"}, it.questionText || "");
    const actions = h("div",{class:"actions"});
    const btnO = h("button", {onclick:(e)=>{ e.stopPropagation(); selectAnswer(it,"O"); }}, "O");
    const btnX = h("button", {onclick:(e)=>{ e.stopPropagation(); selectAnswer(it,"X"); }}, "X");
    if (it.answer==="O") btnO.classList.add("active"); else if (it.answer==="X") btnX.classList.add("active");
    const btnEdit = h("button", {onclick:(e)=>{ e.stopPropagation(); toggleEditor(card,true); settings.currentEditId = it.id; saveSettings(settings); }}, "수정");
    const btnMark = h("button", {onclick:(e)=>{ e.stopPropagation(); it.markReview=!it.markReview; save(items); render(); }}, it.markReview?"검토 해제":"검토 표시");
    const btnHL = h("button", {onclick:(e)=>{ e.stopPropagation(); showHighlight(card, it); }}, "하이라이트");
    const btnDelete = h("button", {onclick:(e)=>{ e.stopPropagation(); if(confirm('이 문제를 삭제할까요?')){ items.splice(idx,1); save(items); render(); } }}, "삭제");
    actions.append(btnO, btnX, btnEdit, btnMark, btnHL, btnDelete);

    const det = h("details",{},
      h("summary",{}, "해설/비교 보기"),
      h("div", {class:"small", style:"margin-top:8px"}, 
        h("div",{}, "해설(원문/전문 또는 요지):"),
        h("div",{}, it.explanation || ""),
        h("div",{style:"margin-top:8px"}, "비교조문/메모: " + (it.compareNote || "—"))
      )
    );
    const hlBox = h("div", {id: "hl-"+it.id, style:"margin-top:8px"});

    const editor = h("div",{class:"editor"});
    editor.append(
      labelInput("조문 표기", it, "articleLabel"),
      labelTextarea("문제 문장", it, "questionText"),
      labelInput("정답 (O/X)", it, "answer"),
      labelTextarea("해설(원문/전문)", it, "explanation"),
      labelInput("비교조문/메모", it, "compareNote"),
      labelInput("트랩 유형(쉼표 구분)", it, "trapTypes"),
      h("div",{class:"actions"},
        h("button",{onclick:(e)=>{ e.stopPropagation(); toggleEditor(card,false); save(items); render(); }}, "저장"),
        h("button",{onclick:(e)=>{ e.stopPropagation(); toggleEditor(card,false); render(); }}, "취소")
      )
    );

    card.append(meta, pin, question, actions, det, hlBox, editor);
    root.appendChild(card);

    if (settings.editMode && settings.currentEditId === it.id) {
      toggleEditor(card, true, true);
    }

    card.addEventListener("keydown",(ev)=>{
      if (ev.key==="o" || ev.key==="O") { selectAnswer(it,"O"); ev.preventDefault(); }
      if (ev.key==="x" || ev.key==="X") { selectAnswer(it,"X"); ev.preventDefault(); }
      if (ev.key==="e" || ev.key==="E") { openEditorFor(it.id); ev.preventDefault(); }
      if (ev.key==="s" || ev.key==="S") {
        const ed = card.querySelector(".editor");
        if (ed.style.display==="block"){ toggleEditor(card,false); save(items); render(); ev.preventDefault(); }
      }
      if (ev.key==="m" || ev.key==="M") { it.markReview=!it.markReview; save(items); render(); ev.preventDefault(); }
    });
  });
  empty.style.display = count ? "none" : "block";
}

function showHighlight(card, it){
  const box = card.querySelector("#hl-"+it.id);
  const html = renderDiff(String(it.explanation||""), String(it.questionText||""));
  box.innerHTML = html;
  box.scrollIntoView({behavior:"smooth", block:"center"});
}

function labelInput(title, it, key){
  const wrap = h("div",{});
  wrap.append(h("label",{}, title));
  const inp = h("input",{type:"text", value: it[key] || ""});
  inp.addEventListener("input", ()=>{ it[key] = inp.value; save(items); });
  wrap.append(inp);
  return wrap;
}
function labelTextarea(title, it, key){
  const wrap = h("div",{});
  wrap.append(h("label",{}, title));
  const ta = h("textarea",{rows:"5"}, it[key] || "");
  ta.addEventListener("input", ()=>{ it[key] = ta.value; save(items); });
  wrap.append(ta);
  return wrap;
}

function selectAnswer(it, val){
  it.answer = val;
  save(items);
  render();
}
function toggleEditor(card, on, focusFirst=false){
  const ed = card.querySelector(".editor");
  if (on){
    document.querySelectorAll(".editor").forEach(el=> el.style.display = "none");
  }
  ed.style.display = on ? "block" : "none";
  if (on && focusFirst){
    const first = ed.querySelector("input,textarea");
    if (first) first.focus({preventScroll:true});
    card.scrollIntoView({behavior:"smooth", block:"center"});
  }
}
function quickEdit(id){
  settings.editMode = true;
  settings.currentEditId = id;
  saveSettings(settings);
  location.hash = "edit=" + id;
  render();
}
function openEditorFor(id){
  settings.currentEditId = id;
  saveSettings(settings);
  location.hash = "edit=" + id;
  const target = document.getElementById(id);
  if (target) toggleEditor(target, true, true);
}

document.getElementById("btnAdd").addEventListener("click", ()=>{
  const it = { id: uid(), articleLabel:"", questionText:"(O/X)", answer:"", explanation:"", compareNote:"", trapTypes:"", markReview:false };
  items.unshift(it);
  save(items); render();
  // 바로 편집 모드로
  settings.editMode = true; settings.currentEditId = it.id; saveSettings(settings);
  location.hash = "edit=" + it.id;
});
document.getElementById("btnExportJson").addEventListener("click", ()=>{
  const blob = new Blob([JSON.stringify(items, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "patent_ox_items.json";
  a.click();
});
document.getElementById("btnExportCsv").addEventListener("click", ()=>{
  const cols = ["id","articleLabel","questionText","answer","explanation","compareNote","trapTypes","markReview"];
  const esc = s => ('\"' + String(s).replace(/\"/g,'\"\"') + '\"');
  const rows = [cols.join(",")].concat(items.map(it=>cols.map(c=>esc(it[c] ?? "")).join(",")));
  const blob = new Blob([rows.join("\\n")], {type:"text/csv;charset=utf-8"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "patent_ox_items.csv";
  a.click();
});
document.getElementById("btnImport").addEventListener("click", (ev)=>{
  // If Alt key pressed, show legacy paste prompt
  if (ev.altKey){
    const text = prompt("JSON 붙여넣기(배열 형태):");
    if (!text) return;
    try{
      const arr = JSON.parse(text);
      if (!Array.isArray(arr)) throw new Error("배열이 아닙니다.");
      items = arr;
      save(items); render();
    } catch(e){
      alert("가져오기 실패: " + e.message);
    }
    return;
  }
  // Otherwise open file picker
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = 'application/json';
  input.onchange = () => {
    const file = input.files && input.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      try{
        const data = JSON.parse(reader.result);
        if (!Array.isArray(data)) throw new Error("JSON 최상위는 배열이어야 합니다.");
        items = data;
        save(items);
        render();
        alert(`불러오기 완료: ${items.length}문항`);
      } catch(e){
        alert("JSON 파싱 실패: " + e.message);
      }
    };
    reader.readAsText(file, 'utf-8');
  };
  input.click();
});
document.getElementById("btnReset").addEventListener("click", ()=>{
  if (confirm("로컬 저장 데이터를 초기화할까요? (되돌릴 수 없음)")){
    localStorage.removeItem(STORAGE_KEY);
    items = initial;
    render();
  }
});
document.getElementById("btnToggleEdit").addEventListener("click", ()=>{
  settings.editMode = !settings.editMode;
  if (!settings.editMode){ settings.currentEditId = null; location.hash = ""; }
  saveSettings(settings);
  render();
});
document.getElementById("search").addEventListener("input", render);

// initial render
render();
</script>

<script>
// PWA: service worker registration (same filename you already deployed)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('service-worker_blank.js').catch(console.error);
  });
}
  <script src="main.js"></script>
  <script src="import_json_patch.js"></script>
</body>
</html>
